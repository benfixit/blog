---
title: Valid Anagram
created: "2025-12-13"
thumbnail: /valid-anagram.png
description: Different approaches to check if a string is a valid anagram.
published: true
---

## Problem statement
Given two strings `a` and `b`, return `true` if `b` is an anagram of `a`, and `false` otherwise.

> An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.

**Example 1:**

```python
Input: s = "anagram", t = "nagaram"

Output: true
```

[Leetcode link](https://leetcode.com/problems/valid-anagram/description/)

## Approach 1: Sorting

**Intuition**

Going by the definition of an anagram, if we sort both strings, it means the sorted strings will be equal.

**Algorithm**

1. If the lengths of the two strings differ, return false immediately because they cannot be anagrams.
2. Sort the strings.
3. Compare them. If they are equal, return true, otherwise, false.

**Solution**

<CodeSwitcher
  samples={{
    'Python': `
from typing import List

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
                return False
        
        return sorted(s) == sorted(t)
    `,
    'JavaScript': `
var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false;
    }
    
    const newS = s.split("").sort().join("");
    const newT = t.split("").sort().join("");

    return newS === newT;
};
    `
  }}
/>

#### Time complexity: 
The time complexity is `O(NLogN + MLogM)` because we sorted the input.

#### Space complexity: 
The space complexity is `O(1)` or `O(N + M)` depending on whether or not the sorting was in-place.


## Approach 2: Hash Map

**Intuition**

If two strings are anagrams, they must use the same characters with the same frequencies.
So, instead of sorting, we can count the frequency of each character in the strings and use hash maps to store their frequency count.
If both maps contain the same characters with the same frequencies, it means they are anagrams.

**Algorithm**

1. If the lengths of the two strings differ, return false immediately because they cannot be anagrams.
2. Create two hash maps to store the character frequencies for each string.
3. Create a frequency counter helper method that takes a string as an input and returns it frequency count
    - Create an empty hash map to store the frequency count of each character in the string.
    - Loop through the string and count the frequency of each character.
    - Return the hash map.
3. Compare the frequency counters of each string. If they are equal, return true, otherwise, false.

**Solution**

<CodeSwitcher
  samples={{
    'Python': `
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
        sMap = self.__createMap(s)
        tMap = self.__createMap(t)

        for ch in tMap:
            if ch not in sMap or tMap[ch] != sMap[ch]:
                return False
        
        return True
    
    # creates a map of the string character against their frequency of occurence
    def __createMap(self, s: str) -> dict:
        map = dict()

        for ch in s:
            map[ch] = map.get(ch, 0) + 1

        return map

# Short solution using the Counter API
class Solution2:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
                return False
        
        return Counter(s) == Counter(t)
    `,
    'JavaScript': `
var isAnagram = function(s, t) {    
    if (s.length !== t.length) {
        return false;
    }

    const createFreqMap = (str) => {
        const data = {};
        for (let i = 0; i < str.length; i++) {
            const ch = str[i];
            if (!data.hasOwnProperty(ch)) {
                data[ch] = 0;
            }

            data[ch] += 1
        }

        return data;
    }

    const sMap = createFreqMap(s);
    const tMap = createFreqMap(t);

    for (let ch in sMap) {
        if (sMap[ch] !== tMap[ch]) {
            return false;
        }
    }

    return true;
};
    `
  }}
/>

#### Time complexity: 
The time complexity is `O(N + M)`.

#### Space complexity: 
The space complexity is `O(1)` since we have at most 26 different characters.

> Where *n* is the length of string *s* and *m* is the length of string *t*.


## Approach 3: Hash Table

**Intuition**

We can sort the numbers in ascending or descending order and then compare each number with the number that comes before it. This approach works because sorting the numbers will make duplicates stay next to each other. This is more efficient that approach 1.

**Algorithm**

1. Sort the array in ascending or decreasing order.
2. Iterate through the array starting from index 1. 
3. Compare the current number with the previous number.
4. If both numbers are equal, we have found a duplicate â€” return True.
5. If the loop finishes without detecting equal numbers, return False.

**Solution**

<CodeSwitcher
  samples={{
    'Python': `
from typing import List

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        sorted_nums = sorted(nums)
        for i in range(1, len(sorted_nums)):
            if sorted_nums[i] == sorted_nums[i - 1]:
                    return True

        return False
    `,
    'JavaScript': `
var containsDuplicate = function(nums) {
    const sortedNums = nums.sort();

    for (let i = 1; i < sortedNums.length; i++) {
        if (sortedNums[i - 1] === sortedNums[i]) {
            return true;
        }
    }

    return false;
};
    `
  }}
/>

#### Time complexity: 
The time complexity is `O(NLogN)` because we sorted the input.

#### Space complexity: 
The space complexity is `O(1)` or `O(N)` depending on whether or not the sorting was in-place.